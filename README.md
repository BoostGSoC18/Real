# Real
Boost numerical data type for real numbers representation using range arithmetic.

## Introduction

### The problem addressed by boost::real
Several times, when dealing with complex mathematical calculus, numerical errors can be carried from one operation to the next and after several steps, the error may significantly increase obtaining a non trustworthy result. Normally, in these situations, the error is generated by the representation precision limit that truncate those numbers that does not fit in the representation precision generating errors without at least keeping track of the magnitude of the error. When this is the case, the real result is equal to the obtained approximated result plus the error (which is unknown).

Another mayor problem when dealing with real numbers is the irrational numbers representation as the number π or e<sup>π</sup>, they are not handled by the native number data types causing limitations when calculations are based on those numbers. Normally we define a truncation of those numbers that is good enough for our purposes, but many times, the needed precision depends on the operation made and the composition of those operation, therefore, we are unable to determine which is the correct precision until we run the programme.

### The boost::real solution
Boost::real is a real number representation data type that address the mentioned issues using range arithmetic [1] and defining the precision as dynamical to be determined in run-time. The main goal of this data type is to represent a real number "a" as a programme that returns a finite or infinite set of intervals a(k) = [m<sub>k</sub> - e<sub>k</sub>, m<sub>k</sub> + e<sub>k</sub>], K ∈ N ≥ 0, e<sub>k</sub> ≥ 0. Where K1 < K2 ⇒ a(k2) &sub; a(k1). For this purposes, any Boost::real number has a precision const iterator that iterates the set of intervals representing the number.

Also, to allow representing irrational numbers as π or e<sup>π</sup>, boost::real has a constructor that takes as parameter a function pointer, functor (function object with the operator ()) or lambda expression that for any integer n > 0, the function returns the n-th digit of the represented number. For example, the number &frac13 can easily be represented by a program that for any input n > 0, the function returns 3. **Note**: All irrational numbers are assumed to be in the interval (0, 1).

## The boost::real numbers representation
In boost::real, a number has one of the next three representations:

    1. A number is a list of digits where the first ones are the integer part and the last ones are the fractional part. Where does the integer part ends and the fractional part starts is specified by an integer number.
    2. A number is an algorithm that one can ask what is the n-th digit and the algorithm will return that number.
    3. A number is a composition of two numbers related by an operator (+, -, *, /), the number creates pointers to the operands and each time the number is used, the operation is evaluated to return the result.

Because of the third representation type, a number resulting of a complex calculus, is a binary tree where each internal vertex is an operation and the vertex children are its operands. The tree leaves are those numbers represented by either (1) or (2) while the internal vertex are those numbers represented by (3). More information of the used number representation can be found in [3]

## The boost::real precision iterator.
The boost::real::const_precision_iterator is a forward iterator [4] that iterates through the number precision. The iterator returns two numbers, a lower and upper bound that represent the [m<sub>k</sub> - e<sub>k</sub>, m<sub>k</sub> + e<sub>k</sub>] limits of the number for a given precision. Each time the iterator is incremented, the interval range is decreased obtaining a new interval with a better precision. Normally, there is no need to interact with the precision iterator and it is used by the boost::real operators <<, < and >.

## Interface

### Constructors and destructors
    1. boost::real()
    2. boost::real(initializer_list<int> il)
    3. boost::real(const boost::real& x)
    4. boost::~real()
  
> (1) **Default constructor** 
> Creates a real instance that represents the number 0.

> (2) **Initializer list constructor** 
> Creates a real instance that represents the number where 0 is the integer part and the elements of the il list are the digits of the fractional part in the same order.

>(3) **Copy constructor** 
> Creates a copy of the number x, if the number is an operation, then, the constructor creates new copies of the x operands.

> (4) **Default destructor** 
> If the number is an operator, the destructor destroy its operands.

### Operators

    1. boost::real operator+(const boost::real& x) const
    2. boost::real operator-(const boost::real& x) const
    3. boost::real& operator=(const boost::real& x)
    4. bool operator<(const real& other) const
    5. std::ostream& operator<<(std::ostream& os, const boost::real& x)

> (1) Creates a new boost::real number using the third representation. For this purpose, the operator creates copies of *this and x to use as the new real number operands and defines the + as the operation.

> (2) Creates a new boost::real number using the third representation. For this purpose, the operator creates copies of *this and x to use as the new real number operands and defines the - as the operation.

> (3) Uses the copy constructor to create a copy of x stored in *this

> (4) Compares *this with x to check if *this is lower than x. This operator creates two precision iterators (one for each number) and iterates until the number ranges stop overlapping, when that happens, it compare the ranges bounds to determine if *this is less than x. **WARNING:** If *this is equal to x, then the ranges will always overlap, because of this, the operator uses a max precision limit and if that limit is reached, the operator throws a boost::real::precision_exception.

> (5) Creates a const_precision_iterator to print the number using the iterator << operator.

### Other methods

    1. boost::real::const_precision_iterator boost::real::cbegin()

> (1) Construct a new const_precision_iterator that iterate over the *this number precisions.

## boost::real::const_precision_iterator interface

### Constructors
    1. boost::real::const_precision_iterator()
    2. boost::real::const_precision_iterator(real const* x)
    3. boost::real::const_precision_iterator(const boost::real::const_precision_iterator& x)
    
> (1) ** Default constructor **
> Create an empty iterator that does not points any number and thus, cannot yet be iterator.

> (2) Creates a iterator that points to the x number and iterates the number precision. If the number is deleted, the iterator behaviour is undefined.

> (3) ** Copy constructor ** 
> Creates an iterator that points the same number than the x iterator does and is initialized in the same precision that x.


### Operators
    1. void operator++()
    2. std::ostream& operator<<(std::ostream& os, const boost::real::const_precision_iterator& x)

> (1) Increases the pointer to the next precision range o the pointed number. If the pointed number is represented by (1) and the full number precision is reached, then the operator has no effect because the number approximation lower and upper bounds are equals and the number range is the number itself.

> (2) Prints the number range with the next formats depending on the number representation: If the number is represented by (1), the operator prints the full number and separates the integer and the fractional parts by a dot. If the number is represented by (2), the operator truncates the number considering the first max precision limit digits and prints the interval [a, b] where a is the truncation and b is the next number considering the same amount of digits. If the representation is (3), the operator uses the precision iterator to get an approximation of max precision limit, and prints those bounds in the format [a, b].

## Examples



## References
    1. Computable calculus / Oliver Aberth, San Diego : Academic Press, c2001
    2. Lambov, B. (2007). RealLib: An efficient implementation of exact real arithmetic. Mathematical Structures in Computer Science, 17(1), 81-98.
    3. Aberth, O., & Schaefer, M. J. (1992). Precise computation using range arithmetic, via C++. ACM Transactions on Mathematical Software (TOMS), 18(4), 481-491.
    4. https://en.cppreference.com/w/cpp/concept/ForwardIterator
