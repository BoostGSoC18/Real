#ifndef BOOST_REAL_REAL_HPP
#define BOOST_REAL_REAL_HPP

#include <iostream>
#include <vector>
#include <algorithm>
#include <initializer_list>
#include <utility>
#include <functional>

#include <real/number.hpp>
#include <real/real_exception.hpp>
#include <real/real_helpers.hpp>

namespace boost {
    namespace real {

        // Available operations
        enum class OP {ADDITION, SUBTRACT};

        template<typename F>
        class real {

            // Number generated by algorithm
            F _number_function = F();

            // Composed number
            OP _operation;
            real* _lhs_ptr = nullptr;
            real* _rhs_ptr = nullptr;

            // TODO: put as template parameter
            int max_precision = 1;

            real(OP operation, const real& lhs, const real& rhs) {
                this->_lhs_ptr = new real(lhs);
                this->_rhs_ptr = new real(rhs);
                this->_operation = operation;
                this->max_precision = std::max(lhs.max_precision, rhs.max_precision);
            };

            void copy_operands(const real& other) {
                if (other._lhs_ptr != nullptr) {
                    this->_lhs_ptr = new real(*other._lhs_ptr);
                }

                if (other._rhs_ptr != nullptr) {
                    this->_rhs_ptr = new real(*other._rhs_ptr);
                }
            }

        public:

            class const_precision_iterator {
            private:

                // Iterator precision
                int _n = 0;

                // Internal number to iterate
                real const* _real_ptr = nullptr;

                // If the number is a composition, the const_precision_iterator uses the operand iterators
                const_precision_iterator* _lhs_it_ptr = nullptr;
                const_precision_iterator* _rhs_it_ptr = nullptr;

                void calculate_operation_bounds() {

                    if (this->_real_ptr->_operation == OP::ADDITION) {
                        boost::real::helper::add_bounds(
                                this->_lhs_it_ptr->lower_bound,
                                this->_lhs_it_ptr->lower_integer_part,
                                this->_lhs_it_ptr->lower_positive,
                                this->_rhs_it_ptr->lower_bound,
                                this->_rhs_it_ptr->lower_integer_part,
                                this->_rhs_it_ptr->lower_positive,
                                this->lower_bound,
                                this->lower_integer_part,
                                this->lower_positive
                        );
                        boost::real::helper::add_bounds(
                                this->_lhs_it_ptr->upper_bound,
                                this->_lhs_it_ptr->upper_integer_part,
                                this->_lhs_it_ptr->upper_positive,
                                this->_rhs_it_ptr->upper_bound,
                                this->_rhs_it_ptr->upper_integer_part,
                                this->_rhs_it_ptr->upper_positive,
                                this->upper_bound,
                                this->upper_integer_part,
                                this->upper_positive
                        );
                    } else if (this->_real_ptr->_operation == OP::SUBTRACT) {
                        boost::real::helper::subtract_bounds(
                                this->_lhs_it_ptr->lower_bound,
                                this->_lhs_it_ptr->lower_integer_part,
                                this->_lhs_it_ptr->lower_positive,
                                this->_rhs_it_ptr->upper_bound,
                                this->_rhs_it_ptr->upper_integer_part,
                                this->_rhs_it_ptr->upper_positive,
                                this->lower_bound,
                                this->lower_integer_part,
                                this->lower_positive
                        );
                        boost::real::helper::subtract_bounds(
                                this->_lhs_it_ptr->upper_bound,
                                this->_lhs_it_ptr->upper_integer_part,
                                this->_lhs_it_ptr->upper_positive,
                                this->_rhs_it_ptr->lower_bound,
                                this->_rhs_it_ptr->lower_integer_part,
                                this->_rhs_it_ptr->lower_positive,
                                this->upper_bound,
                                this->upper_integer_part,
                                this->upper_positive
                        );
                    }
                }

                void check_and_swap_bounds() {
                    if (!this->_real_ptr->_positive) {
                        this->lower_bound.swap(this->upper_bound);
                        std::swap(this->lower_integer_part, this->upper_integer_part);
                    }
                }

            public:

                // Number range boundaries
                std::vector<int> lower_bound = {};
                std::vector<int> upper_bound = {};
                int lower_integer_part = 0;
                int upper_integer_part = 0;
                bool lower_positive = true;
                bool upper_positive = true;

                const_precision_iterator() = default;

                const_precision_iterator(const const_precision_iterator& other) = default;

                explicit const_precision_iterator(real const* ptr) : _real_ptr(ptr) {

                    if (this->_real_ptr->_operation == OP::RATIONAL) {
                        auto first_integer = this->_real_ptr->_digits.cbegin();
                        auto last_integer = this->_real_ptr->_digits.cbegin();

                        // Lower bound and upper bounds of the number integer part
                        for (int i = 0; i < this->_real_ptr->_integer_part; i++) ++last_integer;
                        this->lower_bound.insert(this->lower_bound.end(), first_integer, last_integer);
                        this->upper_bound.insert(this->upper_bound.end(), first_integer, last_integer);
                        this->upper_bound.at(this->_real_ptr->_integer_part - 1)++;
                        this->lower_integer_part = this->_real_ptr->_integer_part;
                        this->upper_integer_part = this->_real_ptr->_integer_part;
                        this->lower_positive = this->_real_ptr->_positive;
                        this->upper_positive = this->_real_ptr->_positive;
                        this->_n = this->_real_ptr->_integer_part;
                        this->check_and_swap_bounds();

                    } else if (this->_real_ptr->_operation == OP::ALGORITHMIC) {
                        this->lower_bound.push_back(0);
                        this->upper_bound.push_back(1);
                        this->lower_integer_part = 1;
                        this->upper_integer_part = 1;
                        this->_n = 1;
                    } else {
                        this->_lhs_it_ptr = new const_precision_iterator(this->_real_ptr->_lhs_ptr->cbegin());
                        this->_rhs_it_ptr = new const_precision_iterator(this->_real_ptr->_rhs_ptr->cbegin());
                        this->calculate_operation_bounds();
                    }
                }

                void operator++() {

                    if (this->_real_ptr->_operation == OP::RATIONAL) {
                        // Explicit number iteration

                        if (this->_n >= (int)this->_real_ptr->_digits.size()) {
                            this->lower_bound.push_back(0);
                            this->upper_bound.push_back(0);
                            return;
                        }

                        // If the number is negative, the bounds are interpreted as mirrored:
                        // First, the operation is made as positive, and after bound calculation
                        // bounds are swapped to come back to the negative representation.
                        this->check_and_swap_bounds();

                        this->upper_bound.clear();
                        this->lower_bound.push_back(this->_real_ptr->_digits[this->_n]);

                        if (this->_n == (int)this->_real_ptr->_digits.size() - 1) {

                            this->upper_bound.insert(this->upper_bound.begin(), this->lower_bound.cbegin(), this->lower_bound.cend());
                        } else {

                            this->upper_bound.resize(this->lower_bound.size());
                            int carry = 1;
                            for (int i = (int)this->lower_bound.size() - 1; i >= 0; --i) {
                                if (this->lower_bound[i] + carry == 10) {
                                    this->upper_bound[i] = 0;
                                } else {
                                    this->upper_bound[i] = this->lower_bound[i] + carry;
                                    carry = 0;
                                }
                            }

                            if (carry > 0) {
                                this->upper_bound.insert(this->upper_bound.begin(), carry);
                                this->upper_integer_part = this->lower_integer_part + 1;
                            } else {
                                this->upper_integer_part = this->lower_integer_part;
                            }
                        }

                        // If the number is negative, the bounds are interpreted as mirrored.
                        this->check_and_swap_bounds();
                        this->_n++;
                        return;
                    } else if (this->_real_ptr->_operation == OP::ALGORITHMIC) {
                        // Algorithmic number iteration
                        // TODO: Implement
                    } else {
                        // Composed number iteration
                        this->lower_bound.clear();
                        this->upper_bound.clear();

                        // Recursive iteration of the operands
                        ++(*this->_lhs_it_ptr);
                        ++(*this->_rhs_it_ptr);

                        // Final bound calculation
                        this->calculate_operation_bounds();
                    }
                }

                friend std::ostream& operator<<(std::ostream&, const const_precision_iterator&);
            };

            real() = default;

            real(const real& other)  :
                    _digits(other._digits),
                    _integer_part(other._integer_part),
                    _positive(other._positive),
                    _number_ptr(other._number_ptr),
                    _operation(other._operation),
                    max_precision(other.max_precision) { this->copy_operands(other); };

            real(std::initializer_list<int> l) {
                this->_operation = OP::RATIONAL;
                this->_digits.insert(this->_digits.end(), l.begin(), l.end());
                this->max_precision = (int)this->_digits.size();
            };

            real(std::initializer_list<int> l, bool positive) {
                this->_operation = OP::RATIONAL;
                this->_digits.insert(this->_digits.end(), l.begin(), l.end());
                this->_positive = positive;
                this->max_precision = (int)this->_digits.size();
            };

            ~real() {
                delete this->_lhs_ptr;
                this->_lhs_ptr = nullptr;

                delete this->_rhs_ptr;
                this->_rhs_ptr = nullptr;
            }

            /*
             * Returns the nth digit of a base case number (i.e. a number that is not a composition of
             * multiple numbers operations)
             *
             * Requires: this->_operation == OP::NONE
             */
            int get_nth_digit(int n) const {

                if (this->_number_ptr != nullptr) {
                    return this->_number_ptr->get_nth_digit(n);
                }

                if (n > (int)this->_digits.size()) {
                    return 0;
                }

                return this->_digits[n];
            };

            const_precision_iterator cbegin() const {
                return const_precision_iterator(this);
            }

            /************** Operators ******************/

            real operator+(const real& other) const {
                return real(real::OP::ADDITION, *this, other);
            }

            real operator-(const real& other) const {
                return real(real::OP::SUBTRACT, *this, other);
            }

            real& operator=(const real& other) {
                this->_digits = other._digits;
                this->_integer_part = other._integer_part;
                this->_positive = other._positive;
                this->_number_ptr = other._number_ptr;
                this->_operation = other._operation;
                this->max_precision = other.max_precision;
                this->copy_operands(other);
                return *this;
            }

            bool operator<(const real& other) const {
                auto this_it = this->cbegin();
                auto other_it = other.cbegin();

                int current_precision = std::max(this->max_precision, other.max_precision);
                for (int p = 0; p < current_precision; ++p) {
                    // Get more precision
                    ++this_it;
                    ++other_it;

                    if (boost::real::helper::is_lower(this_it.upper_bound, this_it.upper_positive, other_it.lower_bound, other_it.lower_positive)) {
                        return true;
                    }

                    if (boost::real::helper::is_lower(other_it.upper_bound, other_it.upper_positive, this_it.lower_bound, this_it.lower_positive)) {
                        return false;
                    }
                }

                // If the precision is reached and the number ranges still overlap, then we cannot
                // know if they are equals or other es less than this and we throw an error.
                throw boost::real::precision_exception();
            }

            friend std::ostream& operator<<(std::ostream&, const real&);
        };


        // Explicit number definition
        template<>
        class real<int> {

            std::vector<int> _digits = {0};
            int _integer_part = 1;
            bool _positive = true;

            int max_precision;
        public:

            real() = default;

            real(const real& other)  = default;

            real(std::initializer_list<int> digits, int integer_part) :
                    _digits(digits),
                    _integer_part(integer_part),
                    max_precision((int)this->_digits.size())
            {};

            real(std::initializer_list<int> digits, int integer_part, bool positive):
                    _digits(digits),
                    _integer_part(integer_part),
                    _positive(positive),
                    max_precision((int)this->_digits.size())
            {};

            /************** Operators ******************/

            int operator[](int n) const {
                if (n >= (int)this->_digits.size()) {
                    return 0;
                }

                return this->_digits.at(n);
            }

            template <typename T>
            real<OP> operator+(const real<T>& other) const {
                return real<OP>(OP::ADDITION, *this, other);
            }

            real<OP> operator-(const real& other) const {
                return real<OP>(OP::SUBTRACT, *this, other);
            }

            template <typename T>
            real<T> operator=(const real<T>& other) {
                
            };

            bool operator<(const real& other) const {
                auto this_it = this->cbegin();
                auto other_it = other.cbegin();

                int current_precision = std::max(this->max_precision, other.max_precision);
                for (int p = 0; p < current_precision; ++p) {
                    // Get more precision
                    ++this_it;
                    ++other_it;

                    if (boost::real::helper::is_lower(this_it.upper_bound, this_it.upper_positive, other_it.lower_bound, other_it.lower_positive)) {
                        return true;
                    }

                    if (boost::real::helper::is_lower(other_it.upper_bound, other_it.upper_positive, this_it.lower_bound, this_it.lower_positive)) {
                        return false;
                    }
                }

                // If the precision is reached and the number ranges still overlap, then we cannot
                // know if they are equals or other es less than this and we throw an error.
                throw boost::real::precision_exception();
            }
        };

        inline std::ostream& operator<<(std::ostream& os, const real::const_precision_iterator& r_it) {
            std::string lb = boost::real::helper::print_digits(r_it.lower_bound, r_it.lower_integer_part, r_it.lower_positive);
            std::string ub = boost::real::helper::print_digits(r_it.upper_bound, r_it.upper_integer_part, r_it.upper_positive);

            if (lb == ub) {
                os << lb;
            } else {
                os << '[' << lb << ", " << ub << ']';
            }
            return os;
        }

        inline std::ostream& operator<<(std::ostream& os, const real& r) {
            auto it = r.cbegin();
            for (int i = 0; i <= r.max_precision; i++) {
                ++it;
            }
            os << it;
            return os;
        }
    }
}

#endif //BOOST_REAL_REAL_HPP
