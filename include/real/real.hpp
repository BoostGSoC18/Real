#ifndef BOOST_REAL_REAL_HPP
#define BOOST_REAL_REAL_HPP

#include <iostream>
#include <list>
#include <algorithm>
#include <initializer_list>
#include <utility>

#include <real/number.hpp>
#include <real/real_exception.hpp>
#include <real/real_helpers.hpp>

namespace boost {
    namespace real {
        class real {

            // Available operations
            enum class OP {ADDITION, SUBTRACT, NONE};

            // Explicit number definition
            std::list<int> _digits;

            // Number generated by algorithm
            number* _number_ptr = nullptr;

            // Composed number
            OP _operation = OP::NONE;
            real* _lhs_ptr = nullptr;
            real* _rhs_ptr = nullptr;

            // Precision to witch compare numbers, set by default in two.
            int _precision = 2;

            real(OP operation, const real& lhs, const real& rhs) {
                this->_lhs_ptr = new real(lhs);
                this->_rhs_ptr = new real(rhs);
                this->_operation = operation;
                this->_precision = std::max(lhs._precision, rhs._precision);
            };

            void copy_operands(const real& other) {
                if (other._lhs_ptr != nullptr) {
                    this->_lhs_ptr = new real(*other._lhs_ptr);
                }

                if (other._rhs_ptr != nullptr) {
                    this->_rhs_ptr = new real(*other._rhs_ptr);
                }
            }

        public:

            class const_iterator {
            private:

                // Iterator precision
                int _n = 0;

                // Internal number to iterate
                real const* _real_ptr = nullptr;

                // If the number is a composition, the const_iterator uses the operand iterators
                const_iterator* _lhs_it_ptr = nullptr;
                const_iterator* _rhs_it_ptr = nullptr;

            public:

                // Number range boundaries
                std::list<int> _lower_bound = {};
                std::list<int> _upper_bound = {};
                int _lower_integer_part = 0;
                int _upper_integer_part = 0;

                const_iterator() = default;

                const_iterator(const const_iterator& other) = default;

                explicit const_iterator(real* ptr) : _real_ptr(ptr) {
                    if (this->_real_ptr->_operation == OP::NONE) {
                        this->_lower_bound.push_back(0);
                        this->_upper_bound.push_back(0);
                        this->_lower_integer_part = 1;
                        this->_upper_integer_part = 1;
                    } else {
                        this->_lhs_it_ptr = new const_iterator(this->_real_ptr->_lhs_ptr->begin());
                        this->_rhs_it_ptr = new const_iterator(this->_real_ptr->_rhs_ptr->begin());
                    }

                    ++(*this);
                }

                void operator++() {

                    // Single number iteration
                    // i.e. A number that is not a composition of two number related by an operator
                    if (this->_real_ptr->_operation == OP::NONE) {
                        this->_n++;

                        if (this->_n > (int)this->_real_ptr->_digits.size()) {
                            this->_lower_bound.push_back(0);
                            this->_upper_bound.push_back(0);

                            return;
                        }

                        this->_upper_bound.clear();
                        this->_lower_bound.push_back(this->_real_ptr->get_nth_digit(this->_n));

                        if (this->_n == (int)this->_real_ptr->_digits.size()) {
                            for (auto& d : this->_lower_bound) {
                                this->_upper_bound.push_back(d);
                            }

                            return;
                        }

                        int carry = 1;
                        for (auto it = this->_lower_bound.rbegin(); it != _lower_bound.rend(); ++it) {
                            if (*it + carry == 10) {
                                this->_upper_bound.push_front(0);
                            } else {
                                this->_upper_bound.push_front(*it + carry);
                                carry = 0;
                            }
                        }

                        if (carry > 0) {
                            this->_upper_bound.push_front(carry);
                            this->_upper_integer_part = this->_lower_integer_part + 1;
                        }

                        return;
                    }

                    // Composed number iteration
                    // i.e. a number that is an operation between two real numbers
                    this->_lower_bound.clear();
                    this->_upper_bound.clear();

                    ++(*this->_lhs_it_ptr);
                    ++(*this->_rhs_it_ptr);

                    // TODO: This is only considering addition and subtraction between positive numbers.
                    // TODO: The subtraction assumes lhs >= rhs, otherwise fails.
                    // TODO: positive-negative leq and geq number combination must be considered to get correct result for all the cases.
                    if (this->_real_ptr->_operation == OP::ADDITION) {
                        this->_lower_integer_part = boost::real::helper::add_bounds(this->_lhs_it_ptr->_lower_bound, this->_lhs_it_ptr->_lower_integer_part, this->_rhs_it_ptr->_lower_bound, this->_rhs_it_ptr->_lower_integer_part, this->_lower_bound);
                        this->_upper_integer_part = boost::real::helper::add_bounds(this->_lhs_it_ptr->_upper_bound, this->_lhs_it_ptr->_upper_integer_part, this->_rhs_it_ptr->_upper_bound, this->_rhs_it_ptr->_upper_integer_part, this->_upper_bound);
                    } else if (this->_real_ptr->_operation == OP::SUBTRACT) {
                        this->_lower_integer_part = boost::real::helper::subtract_bounds(this->_lhs_it_ptr->_lower_bound, this->_lhs_it_ptr->_lower_integer_part, this->_rhs_it_ptr->_upper_bound, this->_rhs_it_ptr->_lower_integer_part, this->_lower_bound);
                        this->_upper_integer_part = boost::real::helper::subtract_bounds(this->_lhs_it_ptr->_upper_bound, this->_lhs_it_ptr->_upper_integer_part, this->_rhs_it_ptr->_lower_bound, this->_rhs_it_ptr->_upper_integer_part, this->_upper_bound);
                    }
                }

                void print() {
                    std::cout << '[';
                    int before_dot = this->_lower_integer_part;
                    for (auto& d : this->_lower_bound) {
                        std::cout << d;
                        before_dot--;
                        if (before_dot == 0) std::cout << '.';
                    }

                    std::cout << ", ";

                    before_dot = this->_upper_integer_part;
                    for (auto& d : this->_upper_bound) {
                        std::cout << d;
                        before_dot--;
                        if (before_dot == 0) std::cout << '.';
                    }

                    std::cout << ']';
                }
            };

            real() = default;

            real(const real& other)  :
                    _digits(other._digits),
                    _number_ptr(other._number_ptr),
                    _operation(other._operation),
                    _precision(other._precision) { this->copy_operands(other); };

            real(std::initializer_list<int> l) {
                this->_digits = l;
                this->_precision = (int)this->_digits.size() + 1;
            };

            ~real() {
                delete this->_number_ptr;
                this->_number_ptr = nullptr;

                delete this->_lhs_ptr;
                this->_lhs_ptr = nullptr;

                delete this->_rhs_ptr;
                this->_rhs_ptr = nullptr;
            }

            /*
             * Returns the nth digit of a base case number (i.e. a number that is not a composition of
             * multiple numbers operations)
             *
             * Requires: this->_operation == OP::NONE
             */
            int get_nth_digit(int n) const {

                if (this->_number_ptr != nullptr) {
                    return this->_number_ptr->get_nth_digit(n);
                }

                if (n > (int)this->_digits.size()) {
                    return 0;
                }

                auto it = this->_digits.cbegin();
                for (int i = 1; i < n; i++) { it++; }

                return *it;
            };

            template <typename NUMBER, typename... Args>
            void add_number(Args&&... args) {
                this->_number_ptr = new NUMBER(std::forward<Args>(args)...);
            }

            void print(int precision) {
                auto it = this->begin();
                for (int i = 1; i <= precision; i++) { ++it; }
                it.print();
            }

            const_iterator begin() { return const_iterator(this); }

            /************** Operators ******************/

            real operator+(const real& other) const {
                return real(real::OP::ADDITION, *this, other);
            }

            real operator-(const real& other) const {
                return real(real::OP::SUBTRACT, *this, other);
            }

            real& operator=(const real& other) {
                this->_digits = other._digits;
                this->_number_ptr = other._number_ptr;
                this->_operation = other._operation;
                this->_precision = other._precision;
                this->copy_operands(other);
                return *this;
            };

            //TODO: make this const for operands, the problem is that iterators should be const
            bool operator<(real& other) {
                auto this_it = this->begin();
                auto other_it = other.begin();


                int current_precision = std::max(this->_precision, other._precision);
                for (int p = 0; p < current_precision; ++p) {
                    // Get more precision
                    ++this_it;
                    ++other_it;

                    if (boost::real::helper::is_lower(this_it._upper_bound, other_it._lower_bound)) {
                        return true;
                    }

                    if (boost::real::helper::is_lower(other_it._upper_bound, this_it._lower_bound)) {
                        return false;
                    }
                }

                // If after the precision is reached, the number ranges still overlap, then we cannot
                // know if they are equals or other es less than this and we throw an error.
                throw boost::real::precision_exception();
            }
        };
    }
}

#endif //BOOST_REAL_REAL_HPP
